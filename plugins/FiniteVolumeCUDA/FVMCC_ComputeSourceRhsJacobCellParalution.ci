#include "FiniteVolume/FluxData.hh"
#include "FiniteVolume/FVMCC_BC.hh"

#include "Framework/CellConn.hh"
#include "Framework/LSSMatrix.hh"
#include "Framework/MeshData.hh"
#include "Framework/MathTypes.hh"
#include "Framework/BlockAccumulator.hh"
#include "Framework/CudaDeviceManager.hh"
#include "Common/CUDA/CFVec.hh"

//////////////////////////////////////////////////////////////////////////////

namespace COOLFluiD {

  namespace Numerics {

    namespace FiniteVolume {

//////////////////////////////////////////////////////////////////////////////

template <typename SCHEME, typename PHYSICS,typename SOURCE, typename POLYREC, typename LIMITER, CFuint NB_BLOCK_THREADS>
FVMCC_ComputeSourceRhsJacobCellParalution<SCHEME,PHYSICS,SOURCE,POLYREC,LIMITER,NB_BLOCK_THREADS>::FVMCC_ComputeSourceRhsJacobCellParalution(const std::string& name) :
  FVMCC_ComputeRHS(name), 
  socket_stencil("stencil"),
  socket_uX("uX"),
  socket_uY("uY"),
  socket_uZ("uZ"),
  socket_volumes("volumes"),
  m_cellFaces(CFNULL),
  m_cellNodes(CFNULL),
  m_centerNodes(), 
  m_ghostStates(),
  m_ghostNodes(),
  m_cellInfo(),
  m_cellStencil(),
  m_neighborTypes(),
  m_cellConn(),
  m_nbBlocksPerGridX(),
  m_nbBlocksPerGridY(),
  m_lss(CFNULL),
  m_blockStart(), 
  m_nbCellsInKernel(),
  m_blockStartKernel(), 
  m_blockStartKernelCellID(), 
  m_blockJacobians(),
  _numericalJacob(CFNULL),
  _pertFlux(),
  _fluxDiff(),
  _origState(),
  _bAcc(CFNULL)
{
  this->addConfigOptionsTo(this);
  
  m_onGPU = false;
  setParameter("OnGPU",&m_onGPU);
  
  m_nbCellsPerBlock = 1;
  setParameter("NbCellsPerBlock",&m_nbCellsPerBlock);

  m_useParalutionPtr = false;
  this->setParameter("UseParalutionPtr",&m_useParalutionPtr);

  m_nbKernelBlocks = 64;
  this->setParameter("NbKernelBlocks",&m_nbKernelBlocks);
}
      
//////////////////////////////////////////////////////////////////////////////

template <typename SCHEME, typename PHYSICS, typename SOURCE, typename POLYREC, typename LIMITER, CFuint NB_BLOCK_THREADS>
FVMCC_ComputeSourceRhsJacobCellParalution<SCHEME,PHYSICS,SOURCE,POLYREC,LIMITER,NB_BLOCK_THREADS>::~FVMCC_ComputeSourceRhsJacobCellParalution()
{  
}

//////////////////////////////////////////////////////////////////////////////

template <typename SCHEME, typename PHYSICS, typename SOURCE, typename POLYREC, typename LIMITER, CFuint NB_BLOCK_THREADS>
void FVMCC_ComputeSourceRhsJacobCellParalution<SCHEME,PHYSICS,SOURCE,POLYREC,LIMITER,NB_BLOCK_THREADS>::unsetup()
{  
  FVMCC_ComputeRHS::unsetup();
}

//////////////////////////////////////////////////////////////////////////////

template <typename SCHEME, typename PHYSICS, typename SOURCE, typename POLYREC, typename LIMITER, CFuint NB_BLOCK_THREADS>
void FVMCC_ComputeSourceRhsJacobCellParalution<SCHEME,PHYSICS,SOURCE,POLYREC,LIMITER,NB_BLOCK_THREADS>::defineConfigOptions(Config::OptionList& options)
{
  options.template addConfigOption< bool > ("OnGPU", "Flag telling to solve on GPU");
  options.template addConfigOption< CFuint > ("NbCellsPerBlock", "Number of cells per block");
  options.template addConfigOption< bool > ("UseParalutionPtr", "Build the system on the GPU");
  options.template addConfigOption< CFuint > ("NbKernelBlocks", "Number of kernel blocks");
}
      
//////////////////////////////////////////////////////////////////////////////

template <typename SCHEME, typename PHYSICS, typename SOURCE, typename POLYREC, typename LIMITER, CFuint NB_BLOCK_THREADS>
void FVMCC_ComputeSourceRhsJacobCellParalution<SCHEME,PHYSICS,SOURCE,POLYREC,LIMITER,NB_BLOCK_THREADS>::configure ( Config::ConfigArgs& args )
{
  FVMCC_ComputeRHS::configure(args);
}

//////////////////////////////////////////////////////////////////////////////


template <typename SCHEME, typename PHYSICS, typename SOURCE, typename POLYREC, typename LIMITER, CFuint NB_BLOCK_THREADS>
void FVMCC_ComputeSourceRhsJacobCellParalution<SCHEME,PHYSICS,SOURCE,POLYREC,LIMITER,NB_BLOCK_THREADS>::initializeComputationRHS()
{
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::Common;
  
  CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::initializeComputationRHS() START\n");
  
  // copy locally the ghost states, gstates should be treated as states, with pointers to a 1D storage
  DataHandle < Framework::State* > gstates = socket_gstates.getDataHandle();
  const CFuint nbEqs = PhysicalModelStack::getActive()->getNbEq();
  for (CFuint i = 0; i < gstates.size(); ++i) {
    const State& gs = *gstates[i];
    for (CFuint d = 0; d < nbEqs; ++d) {
      m_ghostStates[i*nbEqs+d] = gs[d];
    }
  } 
  
  //this->getMethodData().getPolyReconstructor()->prepareReconstruction();
  
  // reset to zero all non zero entries in the jacobian
  if (this->getMethodData().doComputeJacobian()) {
    m_lss->getMatrix()->resetToZeroEntries();
  }
  
  this->getMethodData().getPolyReconstructor()->prepareReconstruction();
  
  CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::initializeComputationRHS() END\n");
}
      
//////////////////////////////////////////////////////////////////////////////

template <typename SCHEME, typename PHYSICS, typename SOURCE, typename POLYREC, typename LIMITER, CFuint NB_BLOCK_THREADS>
std::vector<Common::SafePtr<Framework::BaseDataSocketSink> > FVMCC_ComputeSourceRhsJacobCellParalution<SCHEME,PHYSICS,SOURCE,POLYREC,LIMITER,NB_BLOCK_THREADS>::needsSockets()
{
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::Common;
  
  std::vector<SafePtr<BaseDataSocketSink> > result = FVMCC_ComputeRHS::needsSockets();
  result.push_back(&socket_stencil);
  result.push_back(&socket_uX);
  result.push_back(&socket_uY);
  result.push_back(&socket_uZ);
  result.push_back(&socket_volumes);
  return result;
}
      
//////////////////////////////////////////////////////////////////////////////

template <typename SCHEME, typename PHYSICS, typename SOURCE, typename POLYREC, typename LIMITER, CFuint NB_BLOCK_THREADS>
void FVMCC_ComputeSourceRhsJacobCellParalution<SCHEME,PHYSICS,SOURCE,POLYREC,LIMITER,NB_BLOCK_THREADS>::storeStencilData()
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::Common;
  
  CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::storeStencilData() START\n");
  
  // flag the partition ghost states
  cf_assert(socket_gstates.getDataHandle().size() > 0);
  vector<bool> isPartitionState(socket_gstates.getDataHandle().size(), false);
  
  // prepare the building of the faces
  SafePtr<GeometricEntityPool<FaceTrsGeoBuilder> > geoBuilder = getMethodData().getFaceTrsGeoBuilder();
  geoBuilder->getGeoBuilder()->setDataSockets(socket_states, socket_gstates, socket_nodes);
  FaceTrsGeoBuilder::GeoData& geoData = geoBuilder->getDataGE();
  SafePtr<TopologicalRegionSet> currTrs = MeshDataStack::getActive()->getTrs("PartitionFaces");
  const CFuint nbTrsFaces = currTrs->getLocalNbGeoEnts();
  geoData.trs = currTrs;
  
  CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::storeStencilData() => Nb of PartitionFaces = " << nbTrsFaces << "\n");
  
  for (CFuint iFace = 0; iFace < nbTrsFaces; ++iFace) {
    geoData.idx = iFace;
    GeometricEntity*const face = geoBuilder->buildGE();
    const CFuint ghostID = face->getState(1)->getLocalID();
    cf_assert(ghostID < isPartitionState.size());
    isPartitionState[ghostID] = true;
    geoBuilder->releaseGE(); 
  }
  
  // reorder the stencil storage to place face neighbors at first   
  DataHandle<vector<State*> > stencil = socket_stencil.getDataHandle();
  const CFuint nbCells = stencil.size();
  cf_assert(nbCells > 0);
  m_cellInfo.resize(5*nbCells);
  
  CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::storeStencilData() => nbCells = " << nbCells << "\n");
  
  CFuint countStencil = 0;
  CFuint maxNbNeighbors = 0;
  for (CFuint i = 0; i < nbCells; ++i) {
    cf_assert(i < stencil.size());
    maxNbNeighbors = std::max((CFuint)maxNbNeighbors, (CFuint)stencil[i].size());
    countStencil += stencil[i].size();
  }
  
  CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::storeStencilData() => maxNbNeighbors = " << maxNbNeighbors << "\n");
  
  // not all faces belong to the stencil: partition faces are discarded!
  // stencil must be bigger than the local (in this processor) number of cells  
  cf_assert(countStencil > nbCells);
  cf_assert(maxNbNeighbors > 0);
  
  m_cellStencil.resize(countStencil);
  m_neighborTypes.resize(countStencil);
  
  // preallocated array to use for reordering, cell by cell
  vector<State*> tmp; tmp.reserve(maxNbNeighbors);
  
  // create and setup the cell builder
  SafePtr<GeometricEntityPool<CellTrsGeoBuilder> > cellBuilder = getMethodData().getCellTrsGeoBuilder();
  SafePtr<CellTrsGeoBuilder> cellBuilderPtr = cellBuilder->getGeoBuilder();
  CellTrsGeoBuilder::GeoData& cellData = cellBuilder->getDataGE();
  SafePtr<TopologicalRegionSet> cells = MeshDataStack::getActive()->getTrs("InnerCells");
  cellData.trs = cells;
  cf_assert(nbCells == cellData.trs->getLocalNbGeoEnts());
  
  CFuint countN = 0;
  for (CFuint iCell = 0; iCell < nbCells; ++iCell) {
    // build the cell
    cellData.idx = iCell;
    GeometricEntity *const cell = cellBuilder->buildGE();
    const CFuint cellID = cell->getState(0)->getLocalID();
    cf_assert(cellID == iCell);
    cf_assert(iCell < stencil.size());
    vector<State*>& currStencil = stencil[iCell];
    const CFuint stencilSize = currStencil.size();
    cf_assert(stencilSize > 0);
    
    const vector<GeometricEntity*>& faces = *cell->getNeighborGeos();
    const CFuint nbFaces = faces.size();
    cf_assert(nbFaces > 2);
    
    // set the cell info array 
    const CFuint cstart = iCell*5;
    cf_assert(cstart   < m_cellInfo.size());
    cf_assert(cstart+1 < m_cellInfo.size());
    cf_assert(cstart+2 < m_cellInfo.size());
    
    m_cellInfo[cstart]   = countN;      // stencil info start for cell iCell
    m_cellInfo[cstart+1] = stencilSize; // stencil size for cell iCell
    m_cellInfo[cstart+2] = nbFaces;     // number of faces (including partition) for cell iCell
    
    // insert face neighbors first
    CFuint nbActiveFaces = 0;
    for (CFuint iFace = 0; iFace < nbFaces; ++iFace) {
      GeometricEntity *const face = faces[iFace];
      State *const st = (face->getState(0)->getLocalID() == cellID) ? face->getState(1) : face->getState(0);
      
      // WATCH OUT: partition faces must be discarded in the stencil for consistency
      //            with the algorithm computing the stencil
      if (!st->isGhost() || (st->isGhost() && !isPartitionState[st->getLocalID()])) {
        // here you are either internal (updatable or not) or not-partition-boundary ghost state
	// hence you have a VALID local ID
	CFLog(DEBUG_MIN, "st->isGhost() = " << st->isGhost() << ", st->getLocalID() = " << st->getLocalID() << "\n");
	cf_assert(countN < m_cellStencil.size());
	// cf_assert(st->getLocalID() < nbCells) fails on very small meshes for which nb of ghosts >= nbCells 
        cf_assert(countN < m_cellStencil.size());
	m_cellStencil[countN] = st->getLocalID();
	
        // neighbor cell types: internal (1), partition (0), physical boundary (-1)  
        cf_assert(countN < m_neighborTypes.size());
        m_neighborTypes[countN] = (!st->isGhost()) ? 1 : -1;
	
        ++countN;
        ++nbActiveFaces;
      }
    }
    
    cf_assert(cstart+4 < m_cellInfo.size());
    m_cellInfo[cstart+4] = nbActiveFaces; // number of active faces in cell iCell
    
    // CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::storeStencilData() => (iCell,countN) = " << iCell << "," << countN << "\n");
    
    for (CFuint n = 0; n < stencilSize; ++n) {
      cf_assert(n < currStencil.size());
      State *const neighbor = currStencil[n];
      bool found = false;
      for (CFuint iFace = 0; iFace < nbFaces; ++iFace) {
	cf_assert(iFace < faces.size());
	GeometricEntity *const face = faces[iFace];
	State *const st = (face->getState(0)->getLocalID() == cellID) ? face->getState(1) : face->getState(0);
	if (neighbor == st) {
	  found = true;
	  break;
	}
      }
      
      // insert remaining vertex neighbors 
      if(!found) {
	if (!neighbor->isGhost() || (neighbor->isGhost() && !isPartitionState[neighbor->getLocalID()])) {
	  cf_assert(countN < m_cellStencil.size());
	  cf_assert(countN < m_neighborTypes.size());
	  m_cellStencil[countN]   = neighbor->getLocalID();
	  m_neighborTypes[countN] = (!neighbor->isGhost()) ? 1 : -1;
	  ++countN;
	}
      }
      
      // CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::storeStencilData() => found after = " << found << "\n");
    } 
    
    //   CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::storeStencilData() => (iCell,countN+1) = " << iCell << "," << countN << "\n");
    
    cellBuilder->releaseGE();
  }
  CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::storeStencilData() => hello 3\n");
  
  
  cf_assert(countN == m_cellStencil.size());
 
  // set the cell shapes
  SafePtr< vector<ElementTypeData> > elemType = MeshDataStack::getActive()->getElementTypeData();
  const CFuint nbElemTypes = elemType->size();
  CFuint counter = 0;
  for (CFuint iType = 0; iType < nbElemTypes; ++iType) {
    const CFuint nbCellsInType = (*elemType)[iType].getNbElems();
    for (CFuint i = 0; i < nbCellsInType; ++i, ++counter) {
      cf_assert(counter*5+3 < m_cellInfo.size());
      m_cellInfo[counter*5+3] = (*elemType)[iType].getGeoShape();
    }
  }
  
  CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::storeStencilData() END\n");
}
      
//////////////////////////////////////////////////////////////////////////////

template <typename SCHEME, typename PHYSICS, typename SOURCE,typename POLYREC, typename LIMITER, CFuint NB_BLOCK_THREADS>
void FVMCC_ComputeSourceRhsJacobCellParalution<SCHEME,PHYSICS,SOURCE,POLYREC,LIMITER,NB_BLOCK_THREADS>::setup()
{
  CFAUTOTRACE;
  
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::Common;
  
  CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::setup() START\n");
  
  FVMCC_ComputeRHS::setup();
  
  // store locally the cell centers
  // in the future compute them on the GPU, this needs element node connectivity + number of nodes per element info 
  DataHandle < Framework::State*, Framework::GLOBAL > states = socket_states.getDataHandle();
  const CFuint nbCells = states.size(); 
  const CFuint dim = PhysicalModelStack::getActive()->getDim();
  m_centerNodes.resize(0., nbCells*dim);
  cf_assert(m_centerNodes.size() == nbCells*dim);
  for (CFuint i = 0; i < nbCells; ++i) {
    const RealVector& coord = states[i]->getCoordinates();
    for (CFuint d = 0; d <dim; ++d) {
      cf_assert(i*dim+d < m_centerNodes.size());
      m_centerNodes[i*dim+d] = coord[d];
    }
  } //This creates a 3*nbCells long array which contains all the coordinates of the cell centers
  
  // copy locally the ghost states
  DataHandle < Framework::State* > gstates = socket_gstates.getDataHandle();
  const CFuint nbEqs = PhysicalModelStack::getActive()->getNbEq();
  m_ghostStates.resize(gstates.size()*nbEqs);
  m_ghostNodes.resize(gstates.size()*dim);
  for (CFuint i = 0; i < gstates.size(); ++i) {
    const RealVector& gs = gstates[i]->getCoordinates();
    for (CFuint d = 0; d < dim; ++d) {
      cf_assert(i*dim+d < m_ghostNodes.size());
      m_ghostNodes[i*dim+d] = gs[d];
    }
  }
  
  CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::setup() after gstates\n");
  
  storeStencilData();
  
  CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::setup() after storeStencilData\n");
  
  m_cellFaces = MeshDataStack::getActive()->getConnectivity("cellFaces");
  m_cellNodes = MeshDataStack::getActive()->getConnectivity("cellNodes_InnerCells");
  
  // copy of data that will not change during the computation, unless mesh changes
  socket_nodes.getDataHandle().getGlobalArray()->put();
  m_centerNodes.put();
  m_ghostNodes.put(); // this must be copied at each iteration if repositioning is applied
  socket_normals.getDataHandle().getLocalArray()->put();   // this could be computed on the fly inside the GPU
  socket_limiter.getDataHandle().getLocalArray()->put();   // this is needed if the limiter is frozen
  socket_isOutward.getDataHandle().getLocalArray()->put(); // this could be not necessary on the GPU
  m_cellInfo.put();
  m_cellStencil.put();
  m_cellFaces->getPtr()->put(); 
  m_cellNodes->getPtr()->put();
  m_neighborTypes.put();
  
  copyLocalCellConnectivity();	
  
  CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::setup() after copyLocalCellConnectivity\n");
  
  // what about packing m_cellInfo, m_cellStencil and m_neighborTypes in one object? inefficient?
  
  // set the sizes of the grid to launch on the Framework::DEVICE
  const CFuint nbActualBlocks = nbCells/m_nbCellsPerBlock;
  m_nbBlocksPerGridX = std::min(nbActualBlocks, (CFuint)CudaEnv::CudaDeviceManager::getInstance().getNBlocks());
  m_nbBlocksPerGridY = static_cast<CFuint>(std::max((CFreal)1., std::ceil((CFreal)nbActualBlocks/
									  (CFreal)m_nbBlocksPerGridX)));
  CFLog(INFO, "FVMCC_ComputeSourceRhsJacobCellParalution::setup() => Kernel grid sizes: <<< [" << 
	m_nbBlocksPerGridX << " - " << m_nbBlocksPerGridY << "], " << 
	CudaEnv::CudaDeviceManager::getInstance().getNThreads() << ">>>\n");
  cout << m_nbBlocksPerGridX*m_nbBlocksPerGridY  << " >= " << nbCells/m_nbCellsPerBlock << endl;
  cf_assert(m_nbBlocksPerGridX*m_nbBlocksPerGridY >= nbCells/m_nbCellsPerBlock);


  // from FVMCC_ComputeSourceRhsJacobCell
  
  // linear system solver
  m_lss = this->getMethodData().getLinearSystemSolver()[0];
  
  m_blockStart.resize(nbCells);
  
  // very expensive solution: allocate the memory for holding the full matrix
  const CFuint nbEqs2 = nbEqs*nbEqs;
  CFuint countBlocks  = 0;
  CFuint countEntries = 0;
  for (CFuint i = 0; i < nbCells; ++i) {
    m_blockStart[i] = countEntries;
    
    // here we have to consider ghosts
    cf_assert(i*5+4 < this->m_cellInfo.size());
    const CFuint nbFacesInCell = this->m_cellInfo[i*5+4];
    // nonzero blocks: diagonal + off-diagonal blocks
    const CFuint nbNonZeroBlocks = nbFacesInCell+1;
    countBlocks  += nbNonZeroBlocks;
    countEntries += nbNonZeroBlocks*nbEqs2;
  }
  
  const CFuint fullMatrixSize = nbEqs2*countBlocks;
  cf_assert(fullMatrixSize == countEntries);
  
  if (!this->m_onGPU) {
    m_nbCellsInKernel.resize(1, nbCells);
    m_blockStartKernel.resize(1, 0); 
    m_blockStartKernelCellID.resize(1, 0);
    m_blockJacobians.resize(fullMatrixSize);
  } 
  else {
    // looking for a cheap solution to store the sparse matrix, we assemble the jacobian 
    // contributions over multiple kernel calls, so that only entries corresponding to 
    // m_nbKernelBlocks*nThreads cells are computed at once
    const CFuint blocksPerGrid = CudaEnv::CudaDeviceManager::getInstance().getBlocksPerGrid(nbCells);
    const CFuint nThreads = CudaEnv::CudaDeviceManager::getInstance().getNThreads();
    // minimum number of kernel calls to assemble the full RHS + jacobian
    const CFuint sizeb = (blocksPerGrid+(m_nbKernelBlocks-1))/m_nbKernelBlocks;

    CFuint NbBlocks = CudaEnv::CudaDeviceManager::getInstance().getNBlocks();
    printf("nbCells = %d \n", nbCells);
    printf("NBlocks = %d \n", NbBlocks);
    printf("blocksPerGrid = %d \n", blocksPerGrid);
    printf("nThreads = %d \n", nThreads);
    printf("sizeb = %d \n", sizeb);


    // array storing the max number of cells whose RHS+jacobian will be computed in each kernel  
    m_nbCellsInKernel.resize(sizeb,nThreads*m_nbKernelBlocks);
    
    const CFuint nbKernels = m_nbCellsInKernel.size();
    m_blockStartKernel.resize(nbKernels, 0);
    m_blockStartKernelCellID.resize(nbKernels, 0);
    CFuint maxSizeJacobEntries = 0;
    CFuint startCellID = 0;
    CFuint startEntryID = 0;
    printf("nbKernels = %d \n", nbKernels);
    for (CFuint s = 0; s < nbKernels; ++s) {
      const CFuint maxCellID = (s < nbKernels-1) ? startCellID + m_nbCellsInKernel[s] : nbCells-1;
      cf_assert(maxCellID < m_blockStart.size());
      cf_assert(startCellID < m_blockStart.size());
      const CFuint deltaStart = m_blockStart[maxCellID] - m_blockStart[startCellID];
      const CFuint delta = (s < nbKernels-1) ? deltaStart : fullMatrixSize - m_blockStart[startCellID];
      maxSizeJacobEntries = max(maxSizeJacobEntries, delta);
      cf_assert(s < m_blockStartKernel.size());
      cf_assert(s < m_blockStartKernelCellID.size());
      m_blockStartKernel[s] = startEntryID;
      m_blockStartKernelCellID[s] = startCellID;
      startCellID = maxCellID;
      startEntryID += delta;
      printf("s = %d  \t maxSizeJacobEntries = %d  \n", s, maxSizeJacobEntries);
    }

    cf_assert(startCellID  == nbCells-1);
    cf_assert(startEntryID == fullMatrixSize);

    if (maxSizeJacobEntries > fullMatrixSize) {
      CFLog(ERROR, "ERROR!! FVMCC_ComputeRhsJacobCell::setup() => uses maxSizeJacobEntries < fullMatrixSize => "
          << maxSizeJacobEntries << " >= " << fullMatrixSize << "\n"); 
      cf_assert(maxSizeJacobEntries <= fullMatrixSize);
    }
    
    CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCell::setup() => uses maxSizeJacobEntries < fullMatrixSize => " 
	  << maxSizeJacobEntries << " < " << fullMatrixSize << "\n");
    cf_assert(maxSizeJacobEntries <= fullMatrixSize);
    
    if (!this->m_useParalutionPtr){
      // m_blockJacobians is allocated with the maximum possible size needed by a single kernel
      m_blockJacobians.resize(maxSizeJacobEntries);
    }
    // here we need to overwrite m_blockStart in such a way that 
    // m_blockStart[cellID] will give the start in the m_blockJacobians storage for the corresponding kernel ID
    // (each cellID is uniquely assigned to just one kernel ID, i.e. the corresponding RHS+jacobian will be 
    //  computed by just one kernel)
    CFuint cellID = 0;
    CFuint offset = 0; 
    for (CFuint s = 0; s < nbKernels; ++s) {
      const CFuint nbKernelCells = (s < nbKernels-1) ? m_nbCellsInKernel[s] : (nbCells - cellID);
      for (CFuint i = 0; i < nbKernelCells; ++i, ++cellID) {
	cf_assert(cellID < m_blockStart.size());
	m_blockStart[cellID] -= offset;
	if (i == 0) {cf_assert(m_blockStart[cellID] == 0);}
      }
      if (s < nbKernels-1) {
	cf_assert(s   < m_blockStartKernel.size());
	cf_assert(s+1 < m_blockStartKernel.size());
	offset += m_blockStartKernel[s+1]-m_blockStartKernel[s];
      }
    }
    cf_assert(cellID == nbCells);
  }
  
  m_blockStart.put();
  
  // numerical jacobian
  _numericalJacob = &this->getMethodData().getNumericalJacobian();
  
  _pertFlux.resize(nbEqs);
  _fluxDiff.resize(nbEqs);
  _origState.resize(nbEqs);
  
  // block accumulator for boundary jacobians
  _bAcc.reset(m_lss->createBlockAccumulator(1, 1, nbEqs));
  
  CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::setup() END\n");
}
      
//////////////////////////////////////////////////////////////////////////////

template <typename SCHEME, typename PHYSICS, typename SOURCE, typename POLYREC, typename LIMITER, CFuint NB_BLOCK_THREADS>
void FVMCC_ComputeSourceRhsJacobCellParalution<SCHEME,PHYSICS,SOURCE,POLYREC,LIMITER,NB_BLOCK_THREADS>::copyLocalCellConnectivity()
{
  CFAUTOTRACE;
  
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::Common;
  
  // set the cell local connectivity data
  SafePtr< vector<ElementTypeData> > elemType = MeshDataStack::getActive()->getElementTypeData();
  const CFuint nbElemTypes = elemType->size();
  
  m_cellConn.resize(8); // maximum number of types is 8 (@see src/Framework/CFGeoShape.hh)
  for (CFuint iType = 0; iType < nbElemTypes; ++iType) {
    const CFGeoShape::Type shapeIdx = (*elemType)[iType].getGeoShape();
    const Table<CFuint>& conn = *LocalConnectionData::getInstance().getFaceDofLocal
      (shapeIdx, CFPolyOrder::ORDER1, NODE, CFPolyForm::LAGRANGE);
    const CFuint nbCellFaces = conn.nbRows();
    cf_assert(shapeIdx < m_cellConn.size()); 
    cf_assert(nbCellFaces <= 6); // hexa have 6 faces
    
    CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::copyLocalCellConnectivity() => shapeIdx    = " << shapeIdx << "\n");
    CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::copyLocalCellConnectivity() => nbCellFaces = " << nbCellFaces << "\n");
    
    m_cellConn[shapeIdx].setNbFaces(nbCellFaces);
    for (CFuint f = 0; f < nbCellFaces; ++f) {
      const CFuint nbFaceNodes = conn.nbCols(f);
      CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::copyLocalCellConnectivity() => face [" << f << "] has "<< nbFaceNodes << " nodes\n");
      cf_assert(nbFaceNodes <= 4); // quad faces have 4 nodes
      m_cellConn[shapeIdx].setNbFaceNodes(f,nbFaceNodes);
      for (CFuint n = 0; n < nbFaceNodes; ++n) {
	cf_assert(f < 6);
	cf_assert(n < 4);
	const CFuint nodeID = conn(f,n);
	cf_assert(nodeID < 8); // hexa have 8 nodes
	m_cellConn[shapeIdx].setNodeID(f,n,nodeID);
      }
    }
  }
  m_cellConn.put();
}
      
//////////////////////////////////////////////////////////////////////////////
      template <typename SCHEME, typename PHYSICS, typename SOURCE, typename POLYREC, typename LIMITER, CFuint NB_BLOCK_THREADS>
void FVMCC_ComputeSourceRhsJacobCellParalution<SCHEME,PHYSICS,SOURCE,POLYREC,LIMITER,NB_BLOCK_THREADS>::updateSystemMatrix(CFuint kernelID)
{
  CFAUTOTRACE;
  
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::Common;
  
  CFLog(VERBOSE,"FVMCC_ComputeSourceRhsJacobCellParalution::updateSystemMatrix() START\n");
  
  const CFuint nbEqs = PHYSICS::NBEQS; 
  cf_assert(m_blockJacobians.size() > 0);
  cf_assert(0*5+4 <this->m_cellInfo.size());
  const CFuint nbFacesInCell0 = this->m_cellInfo[0*5+4];
  const CFuint nbRows0 = nbFacesInCell0 + 1;
  CFreal* start = &m_blockJacobians[0];  
  auto_ptr<BlockAccumulator> acc(m_lss->createBlockAccumulator(nbRows0, 1, nbEqs, start));
  const CFuint nbCells = this->socket_states.getDataHandle().size(); 
  
  cf_assert(kernelID < m_blockStartKernelCellID.size());
  const CFuint startCellID = m_blockStartKernelCellID[kernelID];
  
  const CFuint nbKernels = m_nbCellsInKernel.size();
  const CFuint nbKernelCells = (kernelID < nbKernels-1) ? m_nbCellsInKernel[kernelID] : (nbCells - startCellID);
  const CFuint endCellID   = startCellID + nbKernelCells;
  cf_assert(endCellID <= nbCells);
  
  DataHandle<State*,GLOBAL > states = this->socket_states.getDataHandle();
  CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::updateSystemMatrix() => startCellID = " << startCellID << 
	", endCellID = " << endCellID << " and nbRows0 = " << nbRows0 << " \n");
  
  // skip contribution to non-updatable states rows, since those must be provided by corresponding owning processes 
  for (CFuint cellID = startCellID; cellID < endCellID; ++cellID) {
    cf_assert(cellID < states.size());
    cf_assert(cellID*5+4 < this->m_cellInfo.size());
    const CFuint nbFacesInCell = this->m_cellInfo[cellID*5+4];
    cf_assert(cellID < m_blockStart.size());
    const CFuint bStartCellID = m_blockStart[cellID]; 
    // cout << "[" << cellID << "] has bStartCellID = " << bStartCellID << endl;
    const CFuint nbRows = nbFacesInCell + 1;
    // cout << "nbRows = " << nbRows << ", bStartCellID = " << bStartCellID << ", m_blockJacobians.size() = " << m_blockJacobians.size() <<  endl;
    cf_assert(bStartCellID < m_blockJacobians.size());
    CFreal* startb = &m_blockJacobians[bStartCellID];  
    acc->resetB(nbRows, 1, nbEqs, startb);
    
    // here we only need to set the IDs, the data are already stored
    cf_assert(cellID < states.size());
    const CFint rowID = (states[cellID]->isParUpdatable()) ? (CFint)cellID : -1;
    acc->setRowIndex(0, rowID);
    acc->setColIndex(0, cellID);
    
    // cout << "Neighbors are ["<< " ";
    cf_assert(cellID*5 < this->m_cellInfo.size());
    const CFuint startStencil = this->m_cellInfo[cellID*5];
    for (CFuint f = 0; f < nbFacesInCell; ++f) { 
      const CFuint index = startStencil + f;
      cf_assert(index < this->m_neighborTypes.size());
      cf_assert(index < this->m_cellStencil.size());
      const CFint stype = this->m_neighborTypes[index]; 
      
      CFint neighID = (stype > 0) ? (CFint)this->m_cellStencil[index] : -1; 
      // here invalidate state ID if not updatable
      if (neighID > -1) {
	cf_assert(neighID < states.size());
	if (!states[neighID]->isParUpdatable()) {neighID = -1;}
      }
      
      // here we are assuming that this block contribution is = 0
      // so adding 0 to block (cellID,cellID) will not harm 
      acc->setRowIndex(f+1, neighID);
      // cout << neighID << " ";
    }
    //  cout << "]" <<endl;
    
    m_lss->getMatrix()->addValues(*acc);
    
     //acc->printToScreen(); //abort();
  }
  
  //m_lss->getMatrix()->printToScreen();
  
  CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::updateSystemMatrix() END\n");
}
      
//////////////////////////////////////////////////////////////////////////////

template <typename SCHEME, typename PHYSICS, typename SOURCE, typename POLYREC, typename LIMITER, CFuint NB_BLOCK_THREADS>
void FVMCC_ComputeSourceRhsJacobCellParalution<SCHEME,PHYSICS,SOURCE,POLYREC,LIMITER,NB_BLOCK_THREADS>::finalizeComputationRHS()
{ 
  using namespace COOLFluiD::Framework;
  
  CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::finalizeComputationRHS() START\n");
  
  // compute dynamically the CFL
  if (this->getMethodData().doComputeJacobian()) {
    this->getMethodData().getCFL()->update();
  }
  
  CFLog(VERBOSE, "FVMCC_ComputeSourceRhsJacobCellParalution::finalizeComputationRHS() END\n");
}
      
//////////////////////////////////////////////////////////////////////////////
 
template <typename SCHEME, typename PHYSICS, typename SOURCE, typename POLYREC, typename LIMITER, CFuint NB_BLOCK_THREADS>
void FVMCC_ComputeSourceRhsJacobCellParalution<SCHEME,PHYSICS,SOURCE,POLYREC,LIMITER,NB_BLOCK_THREADS>::executeBC()
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::Common;
  
  // set the list of faces
  vector<SafePtr<TopologicalRegionSet> > trs = MeshDataStack::getActive()->getTrsList();
  const CFuint nbTRSs = trs.size();
  
  this->_faceIdx = 0;
  
  // no variable perturbation is needed in explicit residual computation
  this->getMethodData().setIsPerturb(false);
  
  // prepare the building of the faces
  Common::SafePtr<GeometricEntityPool<FaceCellTrsGeoBuilder> > geoBuilder = this->getMethodData().getFaceCellTrsGeoBuilder();
  geoBuilder->getGeoBuilder()->setDataSockets(this->socket_states, this->socket_gstates, this->socket_nodes);
  FaceCellTrsGeoBuilder::GeoData& geoData = geoBuilder->getDataGE();
  vector<bool> zeroGrad(PhysicalModelStack::getActive()->getNbEq(), false);
  const bool hasSourceTerm = (this->getMethodData().isAxisymmetric() || this-> getMethodData().hasSourceTerm());
  
  // this could be set during set up with no guarantee that it will be effective:
  // a MethodStrategy could set it to a different value afterwards, before entering here
  geoData.allCells = this->getMethodData().getBuildAllCells();
  
  DataHandle<bool> cellFlag = this->socket_cellFlag.getDataHandle();
  SafePtr<CFMap<CFuint, FVMCC_BC*> > bcMap = this->getMethodData().getMapBC();
  
  for (CFuint iTRS = 0; iTRS < nbTRSs; ++iTRS) {
    SafePtr<TopologicalRegionSet> currTrs = trs[iTRS];
    
    CFLog(VERBOSE, "TRS name = " << currTrs->getName() << "\n");

    // the faces on the boundary of the partition don't have to
    // be processed (their fluxes could give NaN)
    if (currTrs->getName() != "PartitionFaces" && currTrs->getName() != "InnerCells") {
      if (currTrs->hasTag("writable")) {
        this->_currBC = bcMap->find(iTRS);
	
	// set the flag telling if the ghost states have to be placed on the face itself
	this->_currBC->setPutGhostsOnFace();
	
        CFLog(VERBOSE, "BC name = " << this->_currBC->getName() << "\n");
	
        geoData.isBFace = true;
	
	// set the flags specifying the variables for which the boundary condition
	// imposes constant extrapolation (zero gradient)
	this->_polyRec->setZeroGradient(this->_currBC->getZeroGradientsFlags());
	
	// set the current TRS in the geoData
	geoData.faces = currTrs;
	
	const CFuint nbTrsFaces = currTrs->getLocalNbGeoEnts();
	for (CFuint iFace = 0; iFace < nbTrsFaces; ++iFace, ++this->_faceIdx) {
	  CFLogDebugMed( "iFace = " << iFace << "\n");
	  
	  // reset the equation subsystem descriptor
	  PhysicalModelStack::getActive()->resetEquationSubSysDescriptor();
	  
	  // build the GeometricEntity
	  geoData.idx = iFace;
	  this->_currFace = geoBuilder->buildGE();
	  
	  if (this->_currFace->getState(0)->isParUpdatable() || 
	      (!this->_currFace->getState(1)->isGhost() && this->_currFace->getState(1)->isParUpdatable())) {
	    
	    // set the data for the FaceIntegrator
	    this->setFaceIntegratorData();
	    
	    // avoid to recompute the gradient
	    cellFlag[this->_currFace->getState(0)->getLocalID()] = true;
	    
	     //cout << "states = " << this->_currFace->getState(0)->getLocalID()  << ", " <<  this->_currFace->getState(1)->getLocalID() << endl;
	    
	    // extrapolate (and LIMIT, if the reconstruction is linear or more)
	    // the solution in the quadrature points
	    this->_polyRec->extrapolate(this->_currFace);
	    
	    // compute the physical data for each left and right reconstructed
	    // state and in the left and right cell centers
	    this->computePhysicalData();
	    
	    // a jacobian free method requires to re-compute the update coefficient every time the 
	    // residual is calculated to get F*v from the finite difference formula
	    // in particular the time dependent part of the residual depend on a updateCoeff
	    // that has to be up-to-date
	    
	    //   this was very buggy !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!111
	    // this->getMethodData().setIsPerturb(false);
	    // we have to avoid to update updateCoeff
	    this->getMethodData().setIsPerturb(true);

	    // cout << "L = " << *this->_currFace->getState(0) << endl;
	    // cout << "R = " << *this->_currFace->getState(1) << endl;
	    this->_currBC->computeFlux(this->_flux);
	    // cout.precision(12);cout << currTrs->getName() << " C flux = " << _flux << endl;

	    this->computeInterConvDiff();
	    
	    //this->_isDiffusionActive = (*this->_eqFilters)[0]->filterOnGeo(this->_currFace);
	    
	    // if (this->_hasDiffusiveTerm && this->_isDiffusionActive) {
	    //   // reset to false the flag telling to freeze the diffusive coefficients
	    //   this->_diffVar->setFreezeCoeff(false);
	    
	    //   // put virtual function here or parameter
	    //   if (this->_extrapolateInNodes) {
	    // 	this->_nodalExtrapolator->extrapolateInNodes(*this->_currFace->getNodes());
	    //   }
	    //   _diffusiveFlux->computeFlux(_dFlux);
	    //   _flux -= _dFlux;
	    // }
	    
	    //  cout.precision(12);cout << currTrs->getName() << " C+D flux = " << _flux << endl; CFABORT(1);
	    
	    CFLogDebugMed("flux = " <<  this->_flux  << "\n");
	    
	    // compute the source term
	    //if (hasSourceTerm) {			
	    //   this->computeSourceTerm();
	    //}
	    
	    // source term jacobians are only computed while processing internal faces 
	    //_diffVar->setFreezeCoeff(_freezeDiffCoeff);
	    //this->updateRHS(); 
	    computeBoundaryJacobianTerm();
	  }
	  
	  geoBuilder->releaseGE(); 
	}
      }
    }
  }
}


//////////////////////////////////////////////////////////////////////////////

template <typename SCHEME, typename PHYSICS, typename SOURCE, typename POLYREC, typename LIMITER, CFuint NB_BLOCK_THREADS>
void FVMCC_ComputeSourceRhsJacobCellParalution<SCHEME,PHYSICS,SOURCE,POLYREC,LIMITER,NB_BLOCK_THREADS>::computeBoundaryJacobianTerm()
{
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::Common;
  

  this->getMethodData().setIsPerturb(true);
  
  // set the index of the block corresponding to the current
  // state in the jacobian matrix
  const CFuint nbEqs = PhysicalModelStack::getActive()->getNbEq();
  State& currState = *this->_currFace->getState(0);
  State& ghostState = *this->_currFace->getState(1);
  cf_assert(ghostState.isGhost());
  
  if (currState.isParUpdatable()) {
    // const bool isAxi = getMethodData().isAxisymmetric();
    // _upFactor[LEFT] = (!isAxi) ? getResFactor() : getResFactor()*(_rMid*_invr[0]);
    // _upStFactor[LEFT] = (!isAxi) ? -getResFactor() :-getResFactor()*_invr[0];
    
    // copy the original value of the ghost state
    _origState = ghostState;
    _bAcc->setRowColIndex(0, currState.getLocalID());
    
    for (CFuint iVar = 0; iVar < nbEqs; ++iVar) {
      CFLogDebugMax( "Perturbing iVar = " << iVar << "\n");
      
      // set the perturbed variable
      this->getMethodData().setIPerturbVar(iVar);
      
      // perturb the given component of the state vector
      _numericalJacob->perturb(iVar, currState[iVar]);
      
      // compute the ghost state in the perturbed inner state
      this->_currBC->setGhostState(this->_currFace);
            
      // extrapolate (and LIMIT, if the reconstruction is linear or more)
      // the solution in the quadrature points
      this->_polyRec->extrapolate(this->_currFace);
            
      // compute the physical data for each left and right reconstructed
      // state and in the left and right cell centers
      this->computeStatesData();
      
      this->_currBC->computeFlux(_pertFlux);
      
      // if (_hasDiffusiveTerm && _isDiffusionActive) {
      // 	//_nodalExtrapolator->extrapolateInNodes(*this->_currFace->getNodes());
      //   _diffusiveFlux->computeFlux(_dFlux);
      //   _pertFlux -= _dFlux;
      // }

      // compute the finite difference derivative of the flux
      _numericalJacob->computeDerivative(this->getJacobianFlux(),_pertFlux,_fluxDiff);
      
      // addJacobTerm(0, iVar, 0, _bAcc.get());
      _bAcc->addValues(0, 0, iVar, &_fluxDiff[0]);
      
      // restore the unperturbed value
      _numericalJacob->restore(currState[iVar]);
      
      // restore the original ghost state
      ghostState = _origState;
    }
    // compute analytical jacobian for source term 
    // if (this->computeSourceTermJacob(LEFT,_stAnJacobIDs)) {
    //   this->addAnalyticSourceTermJacob(LEFT, _bAcc.get());
    // }
    
    // add the values in the jacobian matrix
    m_lss->getMatrix()->addValues(*_bAcc);
    // std::cout << "BAC" << std::endl;_bAcc->print();
    
    // reset to zero the entries in the block accumulator
    _bAcc->reset();
    // _sourceJacobOnCell[LEFT] = false;
  } 
}
      
//////////////////////////////////////////////////////////////////////////////

    } // namespace FiniteVolume
    
  } // namespace Numerics
  
} // namespace COOLFluiD
